"""
Base agent class for flood monitoring AI agents.
"""

import asyncio
import time
from abc import ABC, abstractmethod
from datetime import datetime, timezone
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, asdict
import json
import logging

from ..settings import settings

logger = logging.getLogger(__name__)

@dataclass
class AgentInsight:
    """Structured insight from an agent"""
    title: str
    value: str
    change: Optional[str] = None
    trend: Optional[str] = None  # 'up', 'down', 'stable'
    urgency: str = 'normal'  # 'low', 'normal', 'high', 'critical'
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now(timezone.utc)
    
    def to_dict(self) -> Dict[str, Any]:
        data = asdict(self)
        data['timestamp'] = self.timestamp.isoformat()
        return data

@dataclass
class AgentAlert:
    """Alert generated by an agent"""
    id: str
    title: str
    message: str
    severity: str  # 'info', 'warning', 'critical'
    source_agent: str
    affected_areas: List[str] = None
    recommendations: List[str] = None
    expires_at: Optional[datetime] = None
    created_at: datetime = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc)
        if self.affected_areas is None:
            self.affected_areas = []
        if self.recommendations is None:
            self.recommendations = []
    
    def to_dict(self) -> Dict[str, Any]:
        data = asdict(self)
        data['created_at'] = self.created_at.isoformat()
        if self.expires_at:
            data['expires_at'] = self.expires_at.isoformat()
        return data

class BaseAgent(ABC):
    """Base class for all flood monitoring agents"""
    
    def __init__(self, name: str, description: str, check_interval: int = 300):
        self.name = name
        self.description = description
        self.check_interval = check_interval  # seconds
        self.is_running = False
        self.last_check = None
        self.last_insights: List[AgentInsight] = []
        self.active_alerts: List[AgentAlert] = []
        self._task = None
        
    @abstractmethod
    async def analyze(self, data: Dict[str, Any]) -> List[AgentInsight]:
        """
        Analyze current data and return insights.
        
        Args:
            data: Current flood data from database
            
        Returns:
            List of insights generated by this agent
        """
        pass
    
    @abstractmethod
    async def check_alerts(self, data: Dict[str, Any]) -> List[AgentAlert]:
        """
        Check for alert conditions and generate alerts.
        
        Args:
            data: Current flood data from database
            
        Returns:
            List of alerts that should be active
        """
        pass
    
    async def start_monitoring(self):
        """Start the agent's monitoring loop"""
        if self.is_running:
            logger.warning(f"Agent {self.name} is already running")
            return
            
        self.is_running = True
        self._task = asyncio.create_task(self._monitoring_loop())
        logger.info(f"Started monitoring agent: {self.name}")
    
    async def stop_monitoring(self):
        """Stop the agent's monitoring loop"""
        if not self.is_running:
            return
            
        self.is_running = False
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
        logger.info(f"Stopped monitoring agent: {self.name}")
    
    async def _monitoring_loop(self):
        """Internal monitoring loop"""
        while self.is_running:
            try:
                await self._run_check()
                await asyncio.sleep(self.check_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in agent {self.name} monitoring loop: {e}")
                await asyncio.sleep(min(self.check_interval, 60))  # Wait at least 1 minute on error
    
    async def _run_check(self):
        """Run a single check cycle"""
        try:
            # Get current data (this would be implemented by each agent)
            data = await self._get_current_data()
            
            # Analyze data and generate insights
            insights = await self.analyze(data)
            self.last_insights = insights
            
            # Check for alerts
            alerts = await self.check_alerts(data)
            self._update_alerts(alerts)
            
            self.last_check = datetime.now(timezone.utc)
            
            logger.debug(f"Agent {self.name} completed check cycle")
            
        except Exception as e:
            logger.error(f"Error in agent {self.name} check cycle: {e}")
    
    async def _get_current_data(self) -> Dict[str, Any]:
        """Get current flood data - to be implemented by subclasses or injected"""
        # This is a placeholder - in practice, agents would get data from the database
        return {}
    
    def _update_alerts(self, new_alerts: List[AgentAlert]):
        """Update the active alerts list"""
        # Remove expired alerts
        now = datetime.now(timezone.utc)
        self.active_alerts = [
            alert for alert in self.active_alerts 
            if alert.expires_at is None or alert.expires_at > now
        ]
        
        # Add new alerts (avoiding duplicates)
        existing_ids = {alert.id for alert in self.active_alerts}
        for alert in new_alerts:
            if alert.id not in existing_ids:
                self.active_alerts.append(alert)
    
    def get_status(self) -> Dict[str, Any]:
        """Get current agent status"""
        return {
            'name': self.name,
            'description': self.description,
            'is_running': self.is_running,
            'last_check': self.last_check.isoformat() if self.last_check else None,
            'check_interval': self.check_interval,
            'insights_count': len(self.last_insights),
            'active_alerts_count': len(self.active_alerts)
        }
    
    def get_insights(self) -> List[Dict[str, Any]]:
        """Get current insights from this agent"""
        if not self.last_insights:
            # Provide default insight if no insights have been generated yet
            default_insight = AgentInsight(
                title=f"ğŸŸ¡ {self.name}",
                value="Initializing...",
                trend="stable",
                urgency="low"
            )
            return [default_insight.to_dict()]
        return [insight.to_dict() for insight in self.last_insights]
    
    def get_alerts(self) -> List[Dict[str, Any]]:
        """Get active alerts from this agent"""
        return [alert.to_dict() for alert in self.active_alerts]

    async def force_check(self) -> Dict[str, Any]:
        """Force an immediate check and return results"""
        await self._run_check()
        return {
            'insights': self.get_insights(),
            'alerts': self.get_alerts(),
            'status': self.get_status()
        }